
# 应用层协议

## http

###  http各个版本的区别
HTTP/1.0：支持多种数据格式，增加POST、HEAD等方法，增加头信息，每次只能发送一个请求（无持久连接）

HTTP/1.1：默认持久连接、请求管道化、增加缓存处理、增加Host字段、支持断点传输分块传输等。

HTTP/2.0：二进制分帧、多路复用、头部压缩、服务器推送

HTTP/3 :基于 QUIC 协议,quic基于udp。


### HTTP 和 HTTPS 有什么区别？

从网络传输上将https仅仅是http的增强版，在tcp所传输的数据包中使用ssl/tls进行加密传输。
在部署上，两者的默认端口不一致。
在浏览器搜索上，seo更加青睐于https协议传输的网站。



### get和post的区别是什么

二者的主要区别在于语义上，get请求用于获取或者查询资源，而post则用于创建或者修改资源。

### 一次完成的http请求的步骤
1，浏览器进行域名-ip查询
2，浏览器向服务器发送http请求
3，服务器处理
4，接收服务器响应
5，渲染响应数据


### http状态码
![](img/Pasted%20image%2020250122162733.png)
### HTTP 是基于 TCP 还是 UDP 的？
http3.0之前是基于tcp,HTTP/3 基于 QUIC 协议，而 QUIC 是基于 UDP 的，但是QUIC在UDP基础上做了优化，保证优势的同时也提高了可靠性。


### HTTP 和 HTTPS 的区别了解么？

https相比于http，主要区别在于加密传输，http在tcp载荷中的传输数据，是通过ssl/tls加密加密，保证了数据的安全性。


### http的长连接和短连接
http的长连接和短连接主要是对于tco的利用方式来划分的，http1.0使用tcp短连接,而http1.1、http2.0使用tcp长连接。（http2.0使用连接池复用tcp连接，而http1.1长时间不使用的连接会自动关闭）
### http的串行处理和并行处理
在http2.0中使用 二进制分帧层 将请求和响应分解为多个帧，这些帧可以交错发送，接收端再重新组装。

http1.1:在一个 TCP 连接上，请求必须按顺序发送和接收，前一个请求未完成时，后续请求会被阻塞（即 队头阻塞 问题）。

http2.0:使用二进制分帧解决了队头阻塞，即在一个tcp连接中并行传输多个http请求的二进制帧。



## websocket

### 什么是websocket协议。

websocket是一种基于tcp连接的全双工协议，即服务端和客户端可以同时发送信息。


### 如何建立websocket协议

建立websocket协议需要通过http协议，客户端需要通过http请求向服务端发起协议协议升级，服务端同意后，响应状态码为101的http请求表示升级成功。


### websocket和http协议的区别

通信机制：http作为一种请求-响应协议，只有由客户端单方面发起请求，服务端进行响应，而websocket作为一种长连接协议则可以进行双向实时通信。

协议前缀：WebSocket 使用 ws:// 或 wss: //，HTTP 使用 http:// 或 https:// 作为协议前缀
WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。
WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）

通信文本，websocket可以自由选择文本帧（UTF-8 编码的文本数据）或者是二进制（如图片、音频、视频等）两者方式，而http1.0使用文本，http2.0使用二进制帧。

### websocket的长连接
websocket的长连接基于tcp的长连接，这一点和http1.1一样。


## DNS

## 为什么DNS会使用UDP？
[blog.51cto.com/u\_11344924/8008770](https://blog.51cto.com/u_11344924/8008770)
实际上会同时使用TCP和UDP，而UDP通常用于域名服务器和dns查询的客户端之间，而TCP则用于域名服务器之间同步数据。
而问题的核心在于为什么要是用UDP，UDP作为不可靠传输，似乎会导致通信失败，但是请注意，与之对应的是轻量化的体积和快速即使性，也就是说使用UDP在不考虑可靠性传输时，是可以实现DNS的需求，即快速传输、体积小，但是问题在于可靠传输，而UDP被称为不可靠传输仅仅是在传输层的机制，通常会在应用层为UDP弥补这方面的缺陷。
# 传输层协议

## tcp和UDP的区别
面向连接，udp只管发，不管是否接收，而tcp会在发送数据之前建立连接。
可靠传输：TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。而udp只管发送，不对发送结果做控制。
传输效率：由于建立连接、可靠传输等服务，tcp的传输效率要低于udp

## tcp

### tcp四元组

源IP、源端口、目的IP、目的端口

只要四元组不同，通信双法就可以区分不同连接进行通信。

但是需要注意的是，作为发送tcp连接的请求方，操作系统会自动分配源端口，保证该位置不同。




### 为什么三次握手可以建立连接？
首先要明确的是建立连接并非是实际意义上的在物理线路上拉了一条网线，而是**通过一种机制确认通信双方拥有通信能力，**

三次握手的实际作用是确认通信对方可以正确接收到自己所发送的初始序号，seq表示当前主机的序列号，ack表示对方主机序列号+1，也就是响应，当通信双发都成功接收到对方主机的ack，也就意味着双方通信主机都可以信任对方主机的通信能力，成功建立连接。从通信流程上，这也是为什么要三次握手，而不是两次握手的原因。


实际通信中的问题：
尽管三次握手建立了信任关系，但在实际通信过程中仍可能出现问题（如网络拥塞、丢包、硬件故障等）。
如果通信过程中出现发送失败的情况，TCP 协议会通过重传机制尝试恢复通信。如果重传失败，连接可能会断开。


### 什么是半连接队列和全连接队列
![[Pasted image 20250112103914.png]]



半连接队列和全连接队列均是针对于服务端而言，具体到三次握手的流程上来说，是由于客户端需要向服务端发送两次握手，而服务端要区分这两次握手而产生的队列。

半连接队列：当服务端接收到来自客户端的SYN请求的连接队列
全连接队列：当服务端收到客户端对 ACK 响应时，意味着三次握手成功完成，服务端会将该连接从半连接队列移动到全连接队列

### 三次握手过程中是否允许传输数据，
在 TCP 三次握手过程中，第三次握手是可以携带数据的(客户端发送完 ACK 确认包之后就进入 ESTABLISHED 状态了)，这一点在 RFC 793 文档中有提到。也就是说，一旦完成了前两次握手，TCP 协议允许数据在第三次握手时开始传输。


### 为什么要四次挥手？又或者说为什么不能把服务端发送的 ACK 和 FIN 合并起来，变成三次挥手？
从流程上来看，四次挥手的作用与三次握手相同，都是为了通知对方主机关闭连接并确认受到回复。

1,（**第一次挥手**）客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个 FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态；
2（**第二次挥手**）,服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入 CLOSE_WAIT 状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被放在已排队等候的其他已接收的数据之后，所以必须要得继续 read 接收缓冲区已接收的数据；
3,（**第三次挥手**）接着，当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，这时服务端就会发一个 FIN 包，这个 FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；
4,客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；
5,（**第四次挥手**）服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；
6,客户端经过 2MSL 时间之后，也进入 CLOSE 状态；
![[Pasted image 20250112104914.png]]


那么为什么服务端要分别发送ACK响应、FIN通知呢？

从流程上可以看出FIN可简单理解为当前主机已经做好关闭连接的准备，而ACK作为立即响应表示正确接收FIN的报文，而并非同意断开连接行为的报文。
两者不能合成一个请求的原因，就是ack立即响应时不具备发送FIN报文的条件，即没有做好断开连接的准备，具体来说就是仍然需要发送或者接收数据。


### 为什么第四次挥手客户端需要等待 2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？

该机制实际上基于一种假设，那就是如果ack没有接收到，则服务端会在2MSL时间内重新发送FIN报文，换言之，如果在2MSL内客户端没有收到服务端重传的FIN报文，则假定服务端已经收到ack响应报文，自行关闭连接。


而更重要的是，假如客户端直接关闭，并发送ack报文，而这个ack丢失，对应服务端就会由于重传计时器重发报文，此时由于客户端链接状态已关闭，就会不予理会，如果没有其他保障机制，服务端就会由于重传机制，一直发送报文
###  TCP流量控制

tcp流量控制是基于接收方与发送方的缓存空闲所决定的一种机制，具体来说，对于通信双方的主机而言，并不能直接确认对方是否能够承载网络通信的缓存，如果发送过多可能会导致缓存区域溢出。
tcp通过滑动窗口这一机制决定了这个问题，在实际发送中接收方会在返回确认报文时携带对发送方窗口大小的要求（字段：rwnd）。

例如，通信主机a和b建立链接之初，b就会携带发送窗口的大小，在接收数据所返回的ack确认报文中对该窗口进行流量控制。


#### 如果流量窗口设置为0怎么办？

发送窗口设置为0时，发送方停止发送数据，而等待接收处理号缓存，有足够空间继续接收网络通信数据时，接收方向发送方发送非零窗口通知。

此时就产生一个问题，如果这个非零窗口通知丢失了怎么办？似乎通信双方都处于等待状态？

tcp在发送方处于零窗口时，会启动一个计时器，超时会主动询问接收方是否可以继续接收数据。


### 如果服务端挂了还怎么断开连接
1. 服务端崩溃但未关闭连接
如果服务端崩溃但操作系统仍在运行，TCP连接可能仍然保持打开状态。
客户端在尝试发送数据时，服务端不会响应，客户端会触发重传机制。
经过多次重传后仍未收到确认，客户端会认为连接已中断，最终关闭连接。
2. 服务端崩溃且操作系统关闭连接
如果服务端崩溃后操作系统检测到并关闭了连接，服务端会发送一个RST（复位）包给客户端。
客户端收到RST包后，会立即关闭连接。
3. 服务端正常关闭连接
如果服务端正常关闭连接（如调用close()或shutdown()），它会发送一个FIN包给客户端，表示连接关闭。
客户端收到FIN包后，会进入TIME_WAIT状态，并发送ACK确认。
客户端随后关闭连接。
4. 客户端检测连接状态
客户端可以通过以下方式检测连接是否正常：
心跳机制：定期发送心跳包，如果长时间未收到响应，则认为连接已断开。
超时机制：设置读/写超时，如果在超时时间内未收到数据，则认为连接已断开。
TCP Keepalive：启用TCP Keepalive选项，系统会定期检测连接状态。

### tcp拥塞控制


开环控制：可以提前获取流量大小，网络通信状况，进而可以设计一个良好的系统
闭环控制：基于反馈对流量进行调节。



相关字段：
cwnd:拥塞窗口
ssthresh:门限


当cwnd< ssthresh,使用慢开始
当cwnd> ssthresh，拥塞避免
当cwnd=  ssthresh，两者皆可


慢开始：发送方每接收到一个ack确认报文，就cwnd++;
拥塞避免：按照传输轮次进行，cwnd++;(传输轮次，将发送窗口的数据全部发送完成，并接收到返回的ack报文)

重传计时器：当发生重传时，将ssthresh=ssthresh/2,cwnd=1.然后执行慢开始算法。


### 快重传和快恢复

当接收方收到未按照顺序发送的数据时，立即向接收方发送ack确认报文，该报文指向按照顺序全部发送的最后一个序号。

例如，假设接收方收到的序列号为
1，2，3，6.7，。。。。，返回序号为2，表明要求发送3号数据
1，3，4，6，7，返回序号为1，表明要求发送2号数据。

请注意，该机制并不影响发送窗口之类的机制，他只是避免因为偶然丢失的数据包而触发的超时计时器。


当发送方收到3个这样的重复确认，就会将响应的报文立即重传，而不是等到该报文段的重传计时器超时。


收到3个重复确认同时执行的还有快恢复算法，将ssthresh、cwnd都等于当前cwnd的一半，然后进行拥塞避免。
### 快重传的意义
快重传是为了解决拥塞避免在偶发的情况下某个确认报文丢失，触发重传计时器，然后重新开始慢开始算法。

通过立即响应3个ack触发发送方的重传，尽可能的避免慢开始算法降低传输效率。


### TCP粘包指的是什么？
[面试官：什么是TCP粘包？粘包原因？如何解决？-CSDN博客](https://blog.csdn.net/weixin_39615182/article/details/126556648)
###  tcp粘包怎么解决
发送方：因为主要是Nagle算法合并导致，故可通过不使用Nagle算法来解决，发送方用TCP_NODELAY选项来关闭。

接收方：这里接收方解决指的是应用层方面，即格式化数据包和附带数据包长度发送，格式化数据包是指为数据包加上开始符和结束符，那么应用程序读取时就能区分出每个数据包的开始和结束。附带数据包长度发送是指在数据包头部定义出数据包的长度，那么程序在读取时，会按照长度读取对应字节数据，保证读取的是单个包，且数据完整，这样就能保证数据包是单个且完整。



# 网络攻击常见方法


## ip欺骗技术（干扰合法用户连接）
假设现在有一个合法用户 (1.1.1.1) 已经同服务器建立正常的连接，攻击者构造攻击的 TCP 数据，伪装自己的 IP 为 1.1.1.1，并向服务器发送一个带有 RST 位的 TCP 数据段。服务器接收到这样的数据后，认为从 1.1.1.1 发送的连接有错误，就会清空缓冲区中建立好的连接。

rst位：当 RST 标志位被设置为 1 时，表示发送方希望立即终止连接，通常是因为发生了某种错误或异常情况。

这时，如果合法用户 1.1.1.1 再发送合法数据，服务器就已经没有这样的连接了，该用户就必须从新开始建立连接。攻击时，伪造大量的 IP 地址，向目标发送 RST 数据，**使服务器不对合法用户服务**。虽然 IP 地址欺骗攻击有着相当难度，但我们应该清醒地意识到，这种攻击非常广泛，入侵往往从这种攻击开始。

## SYN洪水攻击（耗费系统资源）

通过伪造大量的SYN变源或者变源端口的请求，致使服务端生成大量的半连接，耗费系统资源，最终导致服务端无法传输合法流量。

## UDP洪水攻击（耗费系统资源）
UDP Flood 主要通过利用服务器响应发送到其中一个端口的 UDP 数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到 UDP 数据包时，会经过两个步骤：

服务器首先检查是否正在运行正在侦听指定端口的请求的程序。
如果没有程序在该端口接收数据包，则服务器使用 ICMP（ping）数据包进行响应，以通知发送方目的地不可达。


也就是说UDP洪水攻击是利用服务器主机响应UDP不可到达的icmp端口来耗费系统资源。

## HTTP洪水攻击（耗费系统资源）
发送大量http请求系统资源，如向目标服务器发送对图像、文件或其他资产的多个请求，最终导致服务端饱和，停止响应来自正常流量源的请求。


## 什么是ddos攻击
DDos 全名 Distributed Denial of Service，翻译成中文就是分布式拒绝服务。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。
