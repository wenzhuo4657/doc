
# 1，前置概念

## 汇编语言的诞生
由于机器语言难以正常记忆，所以通过汇编指令来进行简化，该步骤仅仅是利于程序员，而并非计算机的优化

## 汇编语言的分类

（1）汇编指令：有对应的机器码，计算机可直接执行
（2）伪指令：没有对应机器码，需要汇编器的执行，通常通常用于定义数据、分配内存、指定程序的起始点等
（3)其他符号：由编译器识别，没有对应的机器码，

*伪指令对于的是伪指令集，是由汇编器定义的一组特殊指令，不能转换为机器码，仅仅是用于辅助汇编指令*



## 存储单元


存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号，例如一个存储器有128个存储单元，编号从
0~127，
![image.png](http://obimage.wenzhuo4657.cn/20240803110115.png)


微机存储器的计量单位是byte，但是对于大容量存储器可使用kb、mb等


## cpu对存储器的操作

必须具体一下三类信息的交互：
（1） 存储单元的地址
（2） 器件的选择，读或写的命令（控制信息）
（3）读或写的*数据*（数据信息）


## 内存地址空间
对于某个cpu来说，它的寻址能力如果是1024，那么这1024个可寻找到的内存单元就构成了这个cpu的内存地址空间，



**主板：每个pc机器中都有一个主板，通俗点将就是一个主电路板，将各种器件焊接在一起。
**接口卡：通过卡槽和pc中的总线连接，受到cpu控制
**rom、ram等等的存储器

*，对于汇编语言来说，通过汇编器将汇编指令翻译为机器代码，然后交由cpu进行执行，所以，编写汇编语言，必须站在cpu层面考虑，因此此处cpu的内存地址空间又被称为逻辑存储器*



# 寄存器
cpu由运算器、控制器、寄存器等元件组成，但对于汇编程序员来说，只有寄存器是能够通过指令进行读写的元件。

![image.png](http://obimage.wenzhuo4657.cn/20240803113729.png)



### 物理地址

在8086处理器中，内部地址总线为16位，但是对外输出为20位，这是由于地址加法器的存在

![image.png](http://obimage.wenzhuo4657.cn/20240803115240.png)


地址加法器采用的段地址来自于段寄存器，而8086cpu有4个段寄存器（**CS,DS,SS,ES**）,

![image.png](http://obimage.wenzhuo4657.cn/20240804095350.png)



### cs（代码寄存器）和ip（指令寄存器）
表示cpu当前要读取指令的*地址*，也就是前面所说的物理地址

在8086cpu中，任意时刻，将cs内容设为m,ip内容设为n，那么cpu将从内存mX16+n单元开始，读取指令并执行。

注意：在8086cpu中，当一条指令被读取并执行完成后，指令指针（IP，Instruction Pointer）会自动递增，以便指向接下来要执行的指令。递增的数量取决于刚刚执行的指令所占用的字节数。



###  修改指令
	mov 传送指令 例：mov ax 123 、mov bx ax   传送的目标为前者，对后者不做影响 
但这mov不能用于修改cs、ip寄存器的值，而是使用  **jmp 段地址：偏移地址**

此外jmp也可只修改ip的值，jmp 某个寄存器（例如 jmp ax ：将ax寄存器的值移动到ip，）




# 实验一：基本指令的使用

*不区分大小写*
（1）r
r：查看寄存器
![image.png](http://obimage.wenzhuo4657.cn/20240803154756.png)

r ax :修改指定寄存器的值
![image.png](http://obimage.wenzhuo4657.cn/20240803154841.png)
经测试，该命令和修改cs、ip的值
（2）d
d:查看内存中的内容，且此处注意*偏移地址递增
![image.png](http://obimage.wenzhuo4657.cn/20240803155100.png)

	d 段地址：偏移地址 : 将列出从指定内存地址开始的128内存单元的内容，

![image.png](http://obimage.wenzhuo4657.cn/20240803155407.png)





d 段地址：偏移地址  结尾偏移地址：指定范围
![image.png](http://obimage.wenzhuo4657.cn/20240803155648.png)


（3） e：修改内存的值

e 段地址：起始偏移地址 数据 数据 ..  ..  ..  ..
![image.png](http://obimage.wenzhuo4657.cn/20240803160241.png)

数据可以是数字 、字符、字符串

（4） U：将内存中的机器指令翻译为汇编指令并显示

![image.png](http://obimage.wenzhuo4657.cn/20240803160718.png)


（5）t:执行机器指令

t:执行cs：ip为起始地址的第一条机器指令

![image.png](http://obimage.wenzhuo4657.cn/20240803161035.png)

（6) a:以汇编的形式在内存中写入机器指令

![image.png](http://obimage.wenzhuo4657.cn/20240803161955.png)


# 寄存器（内存访问

## 内存中字的存储
一个字占用两个内存单元，即2个字节大小，在内存中使用地址连续的两个内存单元进行存储，一个字的低位字节数据存储在低地址的内存单元中，例如 假设使用0、1两个内存单元进行存储，0单元就表示低地址的内存单元。



## 字的传送

![image.png](http://obimage.wenzhuo4657.cn/20240803165137.png)




## 数据段


在8086中，根据需要可以将一组内存单元定义为一个段，例如将一组长度为N，地址连续、起始地址为16的倍数的内存单元当做专门用于存储数据的内存空间，从而定义了一个数据段

注意：这里要求起始地址为16的倍数，是为了简化8086的计算，在8086pc机中的段寄存器中的值，通常要求**段寄存器值×16**之后的**段的低4位总是0**

gpt的回答：
- 低4位总是0的原因是为了确保段寄存器的值可以正确地与偏移量组合，生成合法的20位物理地址。如果低4位不是0，那么在计算物理地址时需要进行额外的位操作或算术操作，这会增加复杂度和潜在的错误。
- 通过确保低4位总是0，8086 CPU可以简单地使用位移操作来生成物理地址，从而简化了硬件设计并提高了效率。



## cpu提供的栈机制
利用数据段定义了出了栈的内存空间，对此所缺少的另外一个要素就是栈顶的物理地址，对此8086pc的做法是，将其地址存入段寄存器SS和寄存器SP，
任意时刻，SS：SP都指向栈顶元素，相关命令有：push,pop


![image.png](http://obimage.wenzhuo4657.cn/20240804092504.png)



- 8086cpu的入栈和出栈操作的基本单位为字，也就是2个内存单元。



### 栈顶超界问题

思考：从pop、push两个命令来看似乎并不需要确认栈空间的大小，因为如何操作、操作程度是如何高级编程语言定义。但这么做依旧有问题，因为无法确定栈空间的大小，这意味着在确定栈空间的地址时没有约束，可能会在符合高级语言定义的情况下，*覆盖其他合法数据*，所以cpu有必要知道这个栈的大小，并据此做出限制。


但是对此，8086cpu并没有做出相关限制。





# 实验二：用机器指令和汇编指令编程
debug命令对于cpu来说是外部的程序，例如 d 1000:0 ,在cpu中不会表示为直接将1000H、0000H作为段地址和偏移地址输入到地址加法器中。在debug程序中，执行d 1000:0命令，会先将1000H作为段地址存入段寄存器中，也就是ds寄存器中。


需要注意的是，debug命令并不是汇编指令，而是外部程序的指令集，也就是伪指令，并没有直接对应的机器代码。



实验结论：debug的T命令在执行修改寄存器SS的指令时，下一条指令也会紧接着执行



# 第一个程序

debug追踪程序运行发现

ds初值为程序所在内存区的段地址，
cs：ip初值为指向程序的第一条指令
cx初值为程序的长度



数据段和栈段在程序加载后实际占据的空间都是以16个字节为单位的。如果不足，以0补全填充。
![image.png](http://obimage.wenzhuo4657.cn/20240804153707.png)


注意，该psp区域并非是某个数据段的区域，而是dos系统自动空闲的，方便程序运用内存区域，也就是说psp不等于程序中的第一个数据段。

# [BX]和loop指令



> [!随笔] 8086cpu中的寄存器
> 在8086中，部分16位的通用寄存器（ax,bx,cx,dx）内部可划分为两个独立的寄存器，
> al,ah,bl,bh,cl,ch,dl,dh
> L（低位），H（高位）









[bx]：表示将bx寄存器的值赋值过来，意义源于汇编代码在debug、源程序的不同解析，
例如 
mov ax,[0] 
在debug模型中，直接输入，可以被正常解析为将ds:0H物理地址的值传送给ax寄存器，但是源程序中（例如通过记事本编写程序）会被编译为mov ax 0,不会将[0]解析为偏移地址，对此，提出了[bx]的解决办法。
除此之外也可以直接给出段地址 使用形如 `mov ax ,ds:[0]`的方式



段前缀：显示的出现在访问内存单元的命令中段地址被称为段前缀
例如：mov ax,ds:[0] 中`ds：`就是一个段前缀



# 包含多个段的程序


前面所编写的程序都仅仅只包含了一个代码段，没有使用其他空间，且提到0:200：0:2FF相对安全，但字节太少了，仅仅只有256个。

所以在程序中如何获取空间是一个问题，方法有两种
- 1，加载程序时自动分配，即预定义的方式
- 2，程序运行时通过代码进行申请。
此处我们仅仅学习第一种。



![image.png](http://obimage.wenzhuo4657.cn/20240804160438.png)


# 数据处理的两个基本问题
（1）处理的数据在什么地方
（2）处理的数据有多长？

## bx ,si,di,bp
在8086cpu中只有这4个寄存器可用于[....]内存单元的寻址，且只能以单独或者固定搭配（bx和si、bx和di、bp和si、bp和di）的形式出现


*8086中，只要【..】存在bp，默认的段寄存器就从ds变为ss*


## 汇编语言中数据位置的表达
（1）立即数（idata）
直接在汇编语言中写出的数据
（2）寄存器
要处理的数据在寄存器中，
（3）段地址和偏移地址：SA：EA



# 转移指令
定义：*可以修改ip，或同时修改cs和ip的指令统称为转移指令*


![image.png](http://obimage.wenzhuo4657.cn/20240805161010.png)


所有的条件转移指令，都是段内短位移，对ip修改的范围在-128~127之间，对应的机器代码中不显示目的地址，而是标明ip位移。


## jmp

jmp地址要给出的两种信息，
（1）转移的目的地址
（2）转移的距离（段间转移、段内短转移、段内近转移）



### jmp short s(s指的是汇编程序中的标号，start等也可以)

段内短转移，对ip修改的范围在-128~127之间，


*假设对应的机器代码是EB03，则03表示位移（ip+位移就得到新地址了），不需要目标地址的地址*


### jmp far ptr 标号 （段间转移，又称远转移）

用标号的地址修改cs和ip




## jcxz条件位移指令

![](http://obimage.wenzhuo4657.cn/20240805163550.png)



## loop指令
![image.png](http://obimage.wenzhuo4657.cn/20240805163711.png)



## call和ret指令
![image.png](http://obimage.wenzhuo4657.cn/20240807134010.png)

![image.png](http://obimage.wenzhuo4657.cn/20240807134023.png)




# 标志寄存器

其内部存储的bit按位其作用，被称为成为状态字（PSW），8086的标志寄存器如下图。

![image.png](http://obimage.wenzhuo4657.cn/20240807141812.png)


根据标志位的值进行转移

![image.png](http://obimage.wenzhuo4657.cn/20240807143249.png)


# 内中断

中断：cpu不在继续向下处理原本的程序，转而去处理这个特殊信息，
中断信息可以来自外部或者内部，本章节仅仅讨论内部中断，对于8086cpu来说，有以下四种情况会触发内中断，

![image.png](http://obimage.wenzhuo4657.cn/20240808094000.png)

中断类型码：8086cpu中用于表示来源的编码，长度为一个字节，共可以表示256种中断源，
![image.png](http://obimage.wenzhuo4657.cn/20240808094247.png)



中断过程，cpu通过中断类型码找到中断向量表，查表后设置cs和ip，这个过程被称为中断过程，（中断向量表中存储的是对应中断类型处理程序的程序入口地址）


## 响应中断的无效情况

例如 ：执行 mov ss,立即数  此时发生中断并不会响应，这是因为其ss：sp代表栈顶，但ss:sp一般连续执行，如果立即中断，对cs、ip压栈的ss：sp指向将是错误的，本质上是需要保证无论如何ss、sp的传送指令都是连续执行，期间即时发生中断也不去响应。


# 中断程序的安装
![image.png](http://obimage.wenzhuo4657.cn/20240808111238.png)








# 端口

cpu可以直接读写的地方：寄存器、内存单元、端口


pc系统中端口范围0-65535



![image.png](http://obimage.wenzhuo4657.cn/20240808112830.png)


![image.png](http://obimage.wenzhuo4657.cn/20240808112920.png)


# 外中断

cpu和各种外设的io通信通过端口，分为可屏蔽中断和不可屏蔽中断。
