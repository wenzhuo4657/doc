# 基本

## mvcc
mvcc是多版本并发控制的简称，是一种在数据库管理系统中实现高并发读写的关键技术，允许在不使用锁机制的情况下，处理多个数据而不发生冲突。

![](https://wenzhuo4657.org/img/9994BA5D9E425F7A4BA0051E4E077B6D.jpg)


# mysql


## 基础架构
![[Pasted image 20250113114328.png]]
连接器：身份认证和权限相关
查询缓存：执行sql时，优先从缓存中查找（**mysql8.0之后将其丢弃**）
分析器：没有命中缓存的话，在分析器中检查sql语句的目的和语法正确性
优化器：对sql进行优化
执行器：执行语句，然后从存储引擎中返回，此处在执行前还会判断权限是否足够
插件式存储引擎：负责数据的存储和读取，采用的插件式架构，


## sql语句执行过程
对于普通的查询语句，直接顺序执行即可，途径连接器验证权限，分析器检查语法，优化器进行优化，执行器对接存储引擎执行并返回数据。

而对于其他修改数据的语句，例如update、insert等，则额外的需要binlog日志和redolog日志。
redolog日志使用两阶段提交来保证binlog日志写入完成，这样操作的好处是可以回滚事务，并且在异常重启时便于判断事务是否执行完成、是否有必要执行对应binlog日志。


且注意，对于修改数据，会先修改在内存中的数据，然后使用日志记录，最后在适当的时机（事务提交时）将内存写入磁盘。

上述说明每一次修改数据都是一次事务的完整进行，即redo log两阶段提交和binlog回滚，但需要注意的是：
1，如果多个修改语句在同一个事务中，则它们会共享同一个 Redo Log 和 Binlog 的提交过程。
2，如果启用了自动提交模式（autocommit=ON），则每个修改语句都会独立地触发 Redo Log 和 Binlog 的写入。（mysql中默认开启）


## 存储引擎架构
mysql存储引擎采用的插件式，且支持第三方自定义，例如早期innnodb就是一个第三方存储引擎，由于过于优秀被Oracel公司收购




## MyISAM 和 InnoDB 的区别是什么？
锁机制支持不同：
myisam仅支持表级锁，而innodb支持表级锁和行级锁，默认为行级锁

事务方面:
myisam不支持事务，InnoDB 提供事务⽀持，并且实现了sql标准定义的四个隔离级别
mvcc:myisam不支持，innodb支持



## 存储引擎的选择
1. InnoDB: 是MySQL的默认存储引擎，支持事务、外键。如果应用对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据
操作除了插入和查询之外，还包含很多的更新、删除 操作，那么InnoDB存储引擎是比较合适的选择
2. MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的，例如日志数据、足迹数据、评论数据。目前被MongoDB代替了

![[Pasted image 20250113114538.png]]


## 为什么不推荐使用外键与级联？

1，在单机场景下尚可完成任务，但是在多源数据库分布式场景下，不能正确完成任务。
2，级联更新是强阻塞，存在数据库更新风暴的问题，外键则影响数据的插入速度。

但是并非说外键和级联不存在优点，只是在分布式场景下不能使用，而当前互联网大部分场景都是分布式，所以不推荐使用，如果是单机场景下，外键和级联可以在较小的代码下完成目标功能，是可以考虑使用的。

## 什么是存储过程？
存储可以简单理解为sql语句的封装，实现代码的重用，避免重复编写。
从应用上将存储过程是一个独立的数据对象，需要通过 EXEC 或 CALL 语句来调用，同时需要需要，存储过程和普通sql语句不能同时使用。


## char和varchar的区别？
char是定长字符串，而varchar是变长字符串。
char在存储时会通过填充空格达到指定长度，取出时去除这些空格。
而varchar则是需要使用额外的1-2字节长度记录字符串长度。

在应用中char适合记录长短差不多的字符串，而varchar则适合存储长短不确定或者差别过大的字符串。


## VARCHAR(100)和 VARCHAR(10)的区别是什么？
在磁盘中存储相同字符串占据空间的大小一致，但是在内存消耗中（指操作这些数据类型的具体数据，而非硬盘中的空间），varchar会分配固定大小管理，也就就是说varchar(100)会比varchar(10)分配的内存空间大。


## NULL 和 '' 的区别是什么？为什么不建议使用null作为默认值
null相比于值更像是一个标识，代表不确定的值，需要通过`IS NULL`和`IS NOT NULL`来判断，不能使用常见的比较运算符，即使是两个NULL值也不一定相等（要看具体的实现）。
而''虽然长度是0，但是根据varchar和char的存储方式，可以知道该值是正确存储于磁盘的。

因此相比null,我们更推荐使用''表示空值，因为它的语义明确、查询简单、性能更好，且代码更易维护。


## mysql中如何表示boolean类型？
MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。

## join连接分类

内连接（inner join /join）：只返回两个表中满足匹配条件的记录
左连接/左外连接（left join /left outer join ）: 以左表为基准，返回所有左表的数据
右连接/右外连接（right join /right outer join ）: 以左表为基准，返回所有左表的数据
全连接/全外连接（full join/full outer join ）:返回两个表的所有行，无论是否匹配。对于左右表中未匹配的行，其列值在结果集中用 NULL 填充。
交叉连接(cross join):返回两个表的笛卡尔积，即每一行与另一表的每一行都进行连接

需要注意的是，上述中的关键字 outer、 inner可以省略，而不影响结果。


## 索引

### 为什么索引能提高查询速度?
这是由于索引的数据结构决定的，索引一般使用红黑树等高效查找，内部使用hash散列比对，


### 最左匹配原则
，
联合索引：使用表中的多个字段创建索引，就是 联合索引。
最左匹配原则是指可以通过联合索引，快速确定一个基础的行范围，增快检索的速度。
在实际执行中则是，数据库只能从索引的最左列开始使用索引。如果查询条件中没有包含索引的最左列，则无法使用该联合索引

例如，对于联合索引 (A, B, C)：

查询条件中包含 A 时，可以使用索引。

查询条件中包含 A 和 B 时，可以使用索引。

查询条件中包含 A、B 和 C 时，可以使用索引。

查询条件中只包含 B 或 C 时，无法使用索引。
### 索引查询的触发条件。

无论是单独的索引还是联合索引，都无需关注查询条件的顺序，而是是否存在。
单独索引：即便不是查询列条件的第一个，优化器也会优先执行索引查询
联合索引：同样无所谓顺序，但是必须从左到右的列必须依次存在



### 索引下推

mysql架构中存在执行器和存储引擎两个模块，而所谓回表的性能缺陷也只是因为存储引擎只能将执行器所需数据返回，无法做额外的判断，而索引下推则是打破了这一缺陷，给与存储引擎判断查询条件的能力。

没有索引下推之前：
存储引擎层先根据 zipcode 索引字段找到所有 zipcode = '431200' 的用户的主键 ID，然后二次回表查询，获取完整的用户数据；
存储引擎层把所有 zipcode = '431200' 的用户数据全部交给 Server 层，Server 层根据MONTH(birthdate) = 3这一条件再进一步做筛选。
有了索引下推之后：

存储引擎层先根据 zipcode 索引字段找到所有 zipcode = '431200' 的用户，然后直接判断 MONTH(birthdate) = 3，筛选出符合条件的主键 ID；
二次回表查询，根据符合条件的主键 ID 去获取完整的用户数据；
存储引擎层把符合条件的用户数据全部交给 Server 层。

### 聚簇索引和非聚簇索引

聚簇索引：叶子节点存储的是**完整的行数据**

非聚簇索引：叶子节点存储索引列的值和主键值


### mysql索引失效场景

[MySQL索引失效的9种场景一起养成写作习惯！这是我参与「掘金日新计划 · 4 月更文挑战」的第6天，点击查看活动详情 - 掘金](https://juejin.cn/post/7083520386498822158)

1，联合索引没有遵从最左匹配+ 范围查询会使联合索引停止匹配
2，对索引字段使用函数或者操作索引字段
例如：`explain select * from class where left(className,4) = '掘金课堂';`
`explain select * from class where id + 1 = 666;`
3,查询条件值的类型和索引类型不匹配
sql底层执行会触发隐式的类型转换，但同时并没有将其进行索引查询
4，使用不等于操作符也会导致索引失效（这里失效的原因，是无法进行逻辑判断，因为索引数据是通过b+树、红黑树进行快速查询的。）
5，模糊查询是，将通配符放在开头（同样是无法进行了逻辑判断）
`explain select * from class where className like "%掘金课堂";`
6,or条件中存在非索引列，导致索引失效
`explain select * from class where id =1 or address = '掘金';`


### 为什么mysql使用b+树作为索引结构？

从查询速度的优化角度来看，首先要解决的磁盘io的读取时间问题，也就是io次数，而mysql查询同时支持范围查询，所以要在保证准确查询的额外，能够进行范围查询。

b+树：
叶子节点：索引值和 记录/主键
非叶子节点：索引值

虽然对于顶部的索引值查询，相比b树速度变慢了，但是胜在io查询次数平均，有一个稳定的查询时间范围，避免了b+树将索引和记录/主键一同读取的无效查询。



## 当前读和快照读的区别

当前读会对记录加锁，避免被其他事务修改。
快照都则是不加锁，由当前事务级别决定读取哪个版本的快照


## mysql事务


### 并发操作带来的问题


脏读：读取了其他用户准备回滚的记录。

幻读：读取了两次，但第二次数据时读取到了其他用户新插入的记录，导致两次读取不一致。（结果集不一致）

不可重复读：其他用户对记录做了修改，导致读取多次时其记录不一致。（单个结果不一致）

更新丢失:由于隔离级别未设置，导致不用用户更新同一记录，但可能会做回滚或者提交等不一致操作，最终导致其更新混乱。


### SQL 标准定义了四个隔离级别：

[事务隔离级别是怎么实现的？ | 小林coding](https://xiaolincoding.com/mysql/transaction/mvcc.html#事务的隔离级别有哪些)

READ-UNCOMMITTED(读取未提交) ： 、
READ-COMMITTED(读取已提交) ： 
REPEATABLE-READ(可重复读) ： 
SERIALIZABLE(可串⾏化) ： 


### mysql隔离级别基于什么实现？默认级别是什么？

基于锁和mvcc机制共同实现。
InnoDB 存储引擎的默认⽀持的隔离级别是 REPEATABLE-READ（可重读）

### 并发事务控制方式
锁和MVCC。
锁分为共享锁和排他锁，其中共享锁可以多个获取，但是排他锁是独占锁。此外根据锁粒度不同，又分为表级锁和行级锁。
MVCC 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

MVCC 在 MySQL 中实现所依赖的手段主要是: 隐藏字段、read view、undo log。

undo log : undo log 用于记录某行数据的多个版本的数据。
read view 和 隐藏字段 : 用来判断当前版本数据的可见性。

### 幻读问题

mysql的innodb支持当前都和快照读，默认隔离级别REPEATABLE-READ（可重读）

对于幻读问题，使用临键锁和mvcc进行控制，但是对于当前读和快照都交叉读取仍然可能会出现幻读。
[MySQL 可重复读隔离级别，完全解决幻读了吗？ | 小林coding](https://xiaolincoding.com/mysql/transaction/phantom.html#第一个发生幻读现象的场景)



## InnoDB 对 MVCC 的具体实现
通过隐藏字段、Read View、undo log，
隐藏字段是针对表中的每行数据所添加的标识，可以记录是否有事务操作该行，操作事务的id,
readview用于记录事务顺序，并以此来进行事务之间的可见性判断。
undo-log则记录有事务操作的记录，其中包含事务操作的数据，可以以此来回滚事务，对事务性可见性的数据支持。


## mysql锁
### 表级锁和行级锁的区别
表级锁是mysql锁中颗粒度最大的一种锁，是针对⾮索引字段加的锁，对当前操作的整张表加锁，实现简单，消耗资源最小，但是也很容易触发锁，因此并发度也是最低的
而行级锁是颗粒度最小的锁，是针对索引字段加的锁，与表级锁相反，实现复杂，耗费资源高，但对并发支持高，同时也更容易出现死锁等问题


### mysql中的行级锁
InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：

记录锁（Record Lock）：属于单个行记录上的锁。
间隙锁（Gap Lock）：锁定一个范围，不包括记录本身。
临键锁（Next-Key Lock）：Record Lock+Gap Lock（**临键锁是记录锁和间隙锁的结合**），锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

### 行级锁使用的注意事项
由于行级锁是针对索引字段锁加的锁，这意味这如果执行的sql没有命令索引，就不会触发行级锁，转而使用表级锁，对全表进行锁定和扫表。


### 为什么临键锁可以解决幻读？
临键锁同时锁定记录和间隙，确保事务执行期间，其他事务无法插入新记录或修改现有记录，从而防止幻读。


### 什么是共享锁和排他锁？
共享锁（S 锁） ：⼜称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。

排他锁（X 锁） ：⼜称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果⼀个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。
排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。



## mysql优化
### 常见优化手段

### sql优化
[你写的每条SQL都是全表扫描吗你写的每条SQL都是全表扫描吗？如果是，那MySQL可太感谢你了，每一次SQL执行都是在给 - 掘金](https://juejin.cn/post/7367163252935786559#heading-1)

1，覆盖索引
例如group by、 where、having

2,避免索引失效

3，减少不必要的查询



## mysql如何保证高可用

主从复制

高可用保证问题：
1，主从最终一致性。（主库所有binlog，备库都执行了）
2，数据不丢失
3，主从延迟


最终实现为主从切换


## 什么会导致慢SQL？
1，索引失效引起全表查询
2，数据页面过大
3，并发瓶颈
4，网络延迟

## 主从复制如何实现？
主库在提交事务时会写入binlog日志，包含事务所有的所有逻辑操作和数据，并且需要注意的是，对于mysql而言没有开启事务的每一个单独的语句都是一个原子事务。
然后从库和主库io连接进行同步这个binlog日志，响应给主库一个完成复制的消息。
从库还有一个专门用于回放binlog日志的线程，去读relay log中继日志（从服务器用来存放主服务器二进制日志内容的一个中间文件），然后回放binlog日志进行同步。

# redis


简介：
redis是一个使用c语言开发的高速缓存数据库，由于其数据是存储在内存中，所以其存取速度十分快，因此被广泛运用于缓存方向，除此之外，还可以做分布式锁，并且，redsi还支持事务、持久化、集群。
## redis的五个基本数据类型
String
hash
list
set
Sorted Set/zset


## 跳表实现


## 为什么使用redis作缓存

可以从高性能、高并发两个方面来讲。
高性能是因为redsi数据存储在内存中，其读写速度十分快，
高并发层面来讲，类似mysql这样的数据库，其qps在1w左右，redsi可以到达其10倍以上，



## Redis 除了做缓存，还能做什么？
分布式锁 ： 通过 Redis 来做分布式锁是⼀种比较常⻅的⽅式。通常情况下，我们都是基于Redisson 来实现分布式锁
消息队列 ：Redis ⾃带的 list 数据结构可以作为⼀个简单的队列使⽤，Redis 5.0 中增加的Stream 类型的数据结构更加适合⽤来做消息队列
分布式 Session ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。


## redis如何实现延迟队列
使用redis有序集合类型zset,将score设置为时间，再利用 zrangebysocre 查询符合条件的所有待处理的任务， 通过循环执行队列任务即可。


## 为什么要用布隆过滤器呢？

**布隆过滤器**适合大规模数据判重和高并发场景，能够显著减少内存占用和提升查询效率，但需要容忍一定的误判率

- **空间效率**：布隆过滤器使用位数组和多个哈希函数，内存占用远小于存储实际数据。
    
- **查询效率**：查询速度非常快，适合高并发场景

## zset实现原理是什么
一种有序的集合sorted set,使用一个额外的参数score为成员排序,内部使用hashmap和跳跃表实现存储和有序,HaspMap存放成员到score的映射，而跳跃表存放所有的成员,使用跳表实现比较高的查询效率,


## 日志

### rdb的怎么用？区别是什么？
rdb是针对于系统内存中的数据进行的全量快照，记录的是实际数据，可以通过save和bgsave运行。
其中对于save是启动主线程，而bgsave则是子线程，此外还可以通过在配置文件中配置save 时间间隔 修改次数，指定默认触发rdb日志的频率，且注意，虽然配置文件中写的save，但实际上执行的bgsave。


###  rdb持久化时，发生写时修改修改怎么办？
该问题通过**Copy-On-Write**技术解决，当fork子进程进行保存快照时，会将物理内存设置为只读模式，此时如果主进程需要修改数据就不能直接修改，而是要先复制对应的内存区块到新的区域进行修改，直到rdb结束，然后合并物理内存区域，这个模式类在java集合中也有应用，即CopyOnWriteArrayList，通过这个cow模式实现了安全失败。

他的核心思想是，当我们要修改内存时，不要在原有区域上修改，而是复制到一块新的区域修改，对应到redis的rdb上则增加了一步，等待只读模式结束，将原有内存区块和复制出去的区块进行合并。



## redis线程模型

对于读写命令，redis一直都是单线程模型，
redis4.0之后引入了多线程对较大的键值对的异步删除操作。
redsi6.0之后引入了多线程来请求网络请求


Redis 服务器是⼀个事件驱动程序，服务器需要处理两类事件：

⽂件事件(file event) ：⽤于处理 Redis 服务器和客户端之间的⽹络 IO。
时间事件(time eveat) ：Redis 服务器中的⼀些操作（⽐如 serverCron 函数）需要在给定的时间点执⾏，⽽时间事件就是处理这类定时操作的。



### redis的单线程模型
redis的单线程模型是基于reactor模型开发的一套高效的事件处理模型，对应的是redis中文件事件处理器，所以一般说redis是单线程模型。



### 如何处理大量客户端连接？

Redis 基于 Reactor 模式开发了⾃⼰的⽹络事件处理器：这个处理器被称为⽂件事件处理器
（file event handler）。⽂件事件处理器使⽤ I/O 多路复⽤（multiplexing）程序来同时监听多个套接字，并根据套接字⽬前执⾏的任务来为套接字关联不同的事件处理器。
当被监听的套接字准备好执⾏连接应答（accept）、读取（read）、写⼊（write）、关 闭
（close）等操作时，与操作相对应的⽂件事件就会产⽣，这时⽂件事件处理器就会调⽤套接字
之前关联好的事件处理器来处理这些事件。
虽然⽂件事件处理器以单线程⽅式运⾏，但通过使⽤ **I/O 多路复⽤程序来监听多个套接字**。





## redis内存管理


### Redis 给缓存数据设置过期时间有啥⽤
这是因为redis的数据存储在内存中，而内存大小有限，如果不设置过期时间，会快速崩溃


### Redis 是如何判断数据是否过期的呢？
Redis 通过⼀个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向
Redis 数据库中的某个 key(键)，过期字典的值是⼀个 long long 类型的整数，这个整数保存了 key
所指向的数据库键的过期时间。

### 过期的数据的删除策略
常见删除策略有
1，惰性删除，只会在取出key时才对数据进行过期检查，
2，定期删除，每隔一段时间从redsi取出一批设置了过期时间的key进行过期删除，并且redis会通过底层限制删除操作执⾏的时⻓和频率来减少删除操作对 CPU 时间的影响。




### Redis 内存淘汰机制了解么？
仅仅通过key删除依旧可能导致大量过期积存在内存当中，此时就需要使用redis的内存淘汰机制
Redis 提供 6 种数据淘汰策略：

1. volatile-lru（least recently used）：从已设置过期时间的数据集中挑选最近最少使⽤的数据淘汰

2. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰

 3. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰

4. allkeys-lru（least recently used）：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最近

最少使⽤的 key（这个是最常⽤的）

5. allkeys-random：从数据集中任意选择数据淘汰

6. no-eviction：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。
这个应该没⼈使⽤吧！



### 常用的缓存读写策略？

旁路缓存模式：
1，查询以cache为主，如果cache不存在则从db中查找返回并进行缓存。
2，更新时先更新db，然后直接删除cache。（这样做的原因时尽量保证查询一致，由于cache缓存的存在，并不会直接查询db，删除cache之后会在访问时自动更新缓存。而如果先删除cache再更新db，则会造成cache与db不一致，并且只能手动清理。）


**读写穿透和异步缓存写入都是以缓存为主、db为备份的策略，这样写入的好处是提高程序的写入速度，而旁路缓存总是要更新db，则是保证了缓存的一致性，除非db中有删改，否则缓存不会改变，有点像cow模式，将cache视为数据库的快照**

*但是仍然需要注意的是，缓存的并发修改问题，最好加上一个独占锁。*

Read/Write Through Pattern（读写穿透）：
1，查询于旁路缓存一致
2，写入：
先查 cache，cache 中不存在，直接更新 db。
cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（同步更新 cache 和 db）。

Write Behind Pattern（异步缓存写入）：
Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。


### 旁路缓存和延迟双删
旁路缓存在更新时，会先写mysql，再删除缓存。

而延迟双删则是说，在更新数据库后，先删除缓存，然后延迟一段时间再次删除缓存。



延时删除缓存：在数据库更新完成后，延迟一段时间（如500毫秒）再次删除缓存，以确保即使有读操作在缓存被删除后但数据库事务未提交时，从数据库读取的旧数据不会被写入缓存。

延迟删除缓存的本质是为了避免并发请求下，将脏数据缓存到redis中（由于数据库写锁的排他性，实际上从程序角度不可能发生，但是在当前互联网场景下，仍然不能忽视网络堵塞以及请求高并发挤爆服务器的情况。），而更糟糕的是删除缓存失败了。

那么延迟双删是为了保证删除数据成功，但是问题是这个时间间隔难以衡量，过大会影响程序性能，过小不足以保证删除脏数据。
此时可以回到问题的本质，即没有删除脏数据，或者说删除数据这个操作失败了。
可以通过消息队列的发送消息，如果删除失败自然会报错，那么拒绝消费这个消息，等待下一次消费。


### redis内存碎片
1、Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。
2、频繁修改 Redis 中的数据也会产生内存碎片。（redis并不会迅速、轻易的释放多余的空间）


查看内存碎片率关键指标`mem_fragmentation_ratio:xxx`
使用redis指令`info memory`,


如何清理 Redis 内存碎片？
（1）Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。
通过 config set 命令将 activedefrag 配置项设置为 yes 开启。
（2）Redis 6.0 及以上版本支持 MEMORY PURGE 命令，可以手动触发内存碎片整理：


### LRU和LFU，以及redis中的应用

LRU：最近最久未使用，通过压栈排除最远被使用的
LFU：最近最不常用，通过记录访问频次，排除最近最少使用的

问题：

LRU：
1，链表结构消耗额外空间
2，需要随着访问变动元素到表头，这对于高并发的redis来说是很严重的性能瓶颈


在redis中的实现，
LRU：采用近似LRU，不适用链表，而是使用其核心思想当中的最近最久未使用，实现方式为：在redis对象结构体当中添加一个额外字段，用于记录最后一次访问时间。
内存淘汰：**随机采样的方式来淘汰数据**，它是随机取 5 个值（此值可配置），然后**淘汰最久没有使用的那个**。

redis4之后引入了LFU算法，用于解决可能会存在，一次性访问大量数据，其中的某些数据之后却不会继续使用。
该算法在LFU的基础上，在对象结构体上增加了访问次数，


##  Redis 持久化机制

### 怎么保证 Redis 挂掉之后再重启数据可以进⾏恢复？

Redis 的⼀种持久化⽅式叫快照rdb，另⼀种⽅式是只追加⽂件aof


### 什么是rdb
rdb是reids中默认的持久化方式，根据某一时间间隔执行数据集的时间快照。例如在配置文件中设置save 900 1，表示每900秒如果有一个key发生变化，就创建一个快照。除此之外在服务停止时也会创建一个快照。


此外还有bgsave，该命令手动执行，会创建一个子线程执行fork命令到新的rdb文件，执行完成后，将覆盖执行命令时最近一次成功的快照

save命令也可以手动执行，但会阻塞主线程，不推荐使用如果是在redis.conf文件配置的话就不同，该配置会触发bgsave，不会阻塞主线程。


### 什么是aof（redis7之後，）
持久性记录服务器收到的*写命令*,在重启时执行（redis7之前仅仅是这样，不会有以下内容，但命令行配置也不同，但此处为面经，不做赘述。）

分为三种类型

| fileType | des                                                                                             | numbers |
| -------- | ----------------------------------------------------------------------------------------------- | ------- |
| BASE     | 表示基础的AOF，它一般由子进程通过重写产生                                                                          | 1       |
| INCR     | 表示增量AOF，它一般会在AOFRW开始创建，                                                                         | >=1     |
| HISTORY  | 表示历史的AOF，它由BASE和INCR AOF变化而来，每次**AOFRW**成功完成时，本次AOFRW之前对应的BASE和INCR都变成HISTORY，此类型AOF会被Redis自动删除 |         |


  aofrw
  重写aof文件，减小文件大小，通过移除冗余的命令实现。例如，set aa 1,set aa 2,最终重写后只会记录set aa 2;



原理：
1、重写操作不执行在原文件中，而是一个临时文件中
2、如果重写失败，即不符合设置文件大小，原文件仍然保存
3.重写期间新的写命令会同时追加进*fork的临时文件*和**原文件**




## redis性能优化
### bigkey
如果一个key对应value占用内存过大就可以被视为bigkey,他消耗过量的内存，对性能造成影响，而且也和redis高速读写的初衷相违背，

寻找bigkey：
1，分析 RDB ⽂件来找出 big key
2，redis自带的参数`--bigkeys`参数来查找


### Hot Key
是指在 Redis 中被频繁访问的键。热 Key 可能会导致 Redis 实例的 CPU 和网络负载过高，甚至成为性能瓶颈

寻找：
1，使用 redis-cli --hotkeys 命令（Redis 6.0+）
2，redis-cli monitor实时监控

解决：
1，将热key存储到本地缓存当中
2，读写分离部署，将读请求分散
3，key分片：将 Key 的数据分散到多个 Redis 实例中，从而将客户端的请求分散到不同的实例上，避免单个实例成为性能瓶颈



## redis生产问题


### redis缓存穿透和缓存击穿、缓存雪崩

[Redis 常见面试题 | 小林coding](https://xiaolincoding.com/redis/base/redis_interview.html#如何避免缓存雪崩、缓存击穿、缓存穿透)


### 缓存击穿已经发生了怎么解决

没上线

互斥锁，从逻辑层面保证有一个线程去兜底，使用布隆过滤器，或者缓存空值


上线
先对数据库进行限流，避免压垮数据库
下架对应操作，从应用层面拒绝流量接入
手动缓存
重启服务。