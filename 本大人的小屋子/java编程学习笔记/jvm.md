
# 栈深度的计算



```
  
public class Main {  
private int count=0;  
public void recursiveCalls(String a,String b,String c){  
count++;  
System.out.println("stack depth: " + count);  
recursiveCalls(a,b,c);  
}  
public void test(){  
try {  
recursiveCalls("a","b","c");  
} catch (Exception e) {  
System.out.println(e);  
}  
}  
  
public static void main(String[] args) {  
new Main().test();  
}  
}
```

经尝试发现，栈深度和内存相关，栈帧的大小和栈深度成负相关，这是否可以将其认为是内存空间释放不及时？进一步增加方法的执行时间，最有效的是debug暂停执行一会，可以明显看到，栈深度大幅度增加，
可以认为，栈深度和栈帧大小成负相关，和内存、方法的执行时间成正相关，总的来说，该问题的根本在于内存不足、栈帧空间释放内存不足以跟上栈帧创建的速度，而并非是出栈。

且注意：对于递归方法，栈帧并没有释放，反倒继续执行，这和程序计数器不同，栈帧队列并非是一出一进，而是有方法执行入栈，有方法执行完成出栈。





# 常量池

## class常量池

参考：[Class常量池 - 程序员自由之路 - 博客园](https://www.cnblogs.com/54chensongxia/p/13708731.html)

常量池，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。
其中符号引用可以视为方法内存入口的中间地址，对比操作系统的逻辑地址与物理地址之间的关系，当jvm不执行就无法获得真正的物理地址，这也是动态链接提出的本意。

此外关于引用类型和运行类型之间的约束，仅仅在编译截断进行检查，这与常量池的符号引用无关。



# JMM内存模型

java线程并不直接修改主存的变量，总是将主存的变量读取到本地内存，该本地内存指的是线程的私有内存空间，此外关于不同本地内存和主存的同步关系，JMM定义了8种操作

锁定（lock）: 作用于主内存中的变量，将他标记为一个线程独享变量。
解锁（unlock）: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。
read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。
load(载入)：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。
use(使用)：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。
assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。
write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。



